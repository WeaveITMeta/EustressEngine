//! # Code Generation
//!
//! Runtime code generation for optimized physics evaluation.
//!
//! ## Usage
//!
//! Generate optimized evaluation code from symbolic expressions
//! for maximum runtime performance.

use std::collections::HashMap;

/// Generated code output format
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CodegenTarget {
    /// Pure Rust code
    Rust,
    /// WGSL shader code
    Wgsl,
    /// GLSL shader code
    Glsl,
}

/// Code generator for physics expressions
pub struct PhysicsCodegen {
    /// Target output format
    pub target: CodegenTarget,
    /// Variable type (f32 or f64)
    pub float_type: FloatType,
    /// Include comments in output
    pub include_comments: bool,
}

/// Float precision type
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FloatType {
    F32,
    F64,
}

impl Default for PhysicsCodegen {
    fn default() -> Self {
        Self {
            target: CodegenTarget::Rust,
            float_type: FloatType::F32,
            include_comments: true,
        }
    }
}

impl PhysicsCodegen {
    /// Generate Rust function for ideal gas law
    pub fn gen_ideal_gas_pressure(&self) -> String {
        let float = match self.float_type {
            FloatType::F32 => "f32",
            FloatType::F64 => "f64",
        };
        
        let comment = if self.include_comments {
            "/// Ideal gas law: P = nRT/V\n"
        } else {
            ""
        };
        
        format!(
            r#"{comment}#[inline]
pub fn ideal_gas_pressure(n: {float}, t: {float}, v: {float}) -> {float} {{
    const R: {float} = 8.314462618;
    if v <= 0.0 {{
        return {float}::INFINITY;
    }}
    (n * R * t) / v
}}"#,
            comment = comment,
            float = float
        )
    }
    
    /// Generate Rust function for kinetic energy
    pub fn gen_kinetic_energy(&self) -> String {
        let float = match self.float_type {
            FloatType::F32 => "f32",
            FloatType::F64 => "f64",
        };
        
        let comment = if self.include_comments {
            "/// Kinetic energy: KE = 0.5*m*v²\n"
        } else {
            ""
        };
        
        format!(
            r#"{comment}#[inline]
pub fn kinetic_energy(mass: {float}, velocity: {float}) -> {float} {{
    0.5 * mass * velocity * velocity
}}"#,
            comment = comment,
            float = float
        )
    }
    
    /// Generate Rust function for drag force
    pub fn gen_drag_force(&self) -> String {
        let float = match self.float_type {
            FloatType::F32 => "f32",
            FloatType::F64 => "f64",
        };
        
        let comment = if self.include_comments {
            "/// Drag force: Fd = 0.5*ρ*v²*Cd*A\n"
        } else {
            ""
        };
        
        format!(
            r#"{comment}#[inline]
pub fn drag_force(density: {float}, velocity: {float}, cd: {float}, area: {float}) -> {float} {{
    0.5 * density * velocity * velocity * cd * area
}}"#,
            comment = comment,
            float = float
        )
    }
    
    /// Generate WGSL compute shader for particle physics
    pub fn gen_particle_compute_shader(&self) -> String {
        r#"// Particle physics compute shader
struct Particle {
    position: vec3<f32>,
    velocity: vec3<f32>,
    mass: f32,
    temperature: f32,
}

@group(0) @binding(0)
var<storage, read_write> particles: array<Particle>;

@group(0) @binding(1)
var<uniform> dt: f32;

@group(0) @binding(2)
var<uniform> gravity: vec3<f32>;

// Ideal gas pressure
fn ideal_gas_pressure(n: f32, t: f32, v: f32) -> f32 {
    let R: f32 = 8.314462618;
    if (v <= 0.0) {
        return 1e10; // Large value instead of infinity
    }
    return (n * R * t) / v;
}

// Kinetic energy
fn kinetic_energy(mass: f32, velocity: vec3<f32>) -> f32 {
    return 0.5 * mass * dot(velocity, velocity);
}

// Drag force magnitude
fn drag_force_magnitude(density: f32, speed: f32, cd: f32, area: f32) -> f32 {
    return 0.5 * density * speed * speed * cd * area;
}

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
    let idx = id.x;
    if (idx >= arrayLength(&particles)) {
        return;
    }
    
    var p = particles[idx];
    
    // Apply gravity
    let acceleration = gravity;
    
    // Update velocity
    p.velocity = p.velocity + acceleration * dt;
    
    // Update position
    p.position = p.position + p.velocity * dt;
    
    particles[idx] = p;
}
"#.to_string()
    }
    
    /// Generate all physics functions as a Rust module
    pub fn gen_physics_module(&self) -> String {
        format!(
            r#"//! Auto-generated physics functions
//! Generated by PhysicsCodegen

{}

{}

{}
"#,
            self.gen_ideal_gas_pressure(),
            self.gen_kinetic_energy(),
            self.gen_drag_force()
        )
    }
}

/// Expression to code converter
pub struct ExpressionCompiler {
    /// Variable mappings
    variables: HashMap<String, String>,
    /// Constant values
    constants: HashMap<String, f64>,
}

impl Default for ExpressionCompiler {
    fn default() -> Self {
        let mut constants = HashMap::new();
        constants.insert("R".to_string(), 8.314462618);
        constants.insert("G".to_string(), 6.67430e-11);
        constants.insert("c".to_string(), 299792458.0);
        constants.insert("pi".to_string(), std::f64::consts::PI);
        constants.insert("e".to_string(), std::f64::consts::E);
        
        Self {
            variables: HashMap::new(),
            constants,
        }
    }
}

impl ExpressionCompiler {
    /// Add a variable mapping
    pub fn add_variable(&mut self, name: &str, rust_name: &str) {
        self.variables.insert(name.to_string(), rust_name.to_string());
    }
    
    /// Add a constant
    pub fn add_constant(&mut self, name: &str, value: f64) {
        self.constants.insert(name.to_string(), value);
    }
    
    /// Compile a simple expression to Rust code
    /// Note: This is a simplified compiler. Full implementation would use
    /// proper parsing and Symbolica's code generation.
    pub fn compile(&self, expr: &str) -> String {
        let mut result = expr.to_string();
        
        // Replace constants
        for (name, value) in &self.constants {
            result = result.replace(name, &format!("{:.15}", value));
        }
        
        // Replace variables
        for (name, rust_name) in &self.variables {
            result = result.replace(name, rust_name);
        }
        
        // Replace ^ with .powf() for exponentiation
        // This is a simplified approach
        result = result.replace("^2", ".powi(2)");
        result = result.replace("^3", ".powi(3)");
        
        result
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_gen_ideal_gas() {
        let codegen = PhysicsCodegen::default();
        let code = codegen.gen_ideal_gas_pressure();
        assert!(code.contains("ideal_gas_pressure"));
        assert!(code.contains("8.314462618"));
    }
    
    #[test]
    fn test_gen_module() {
        let codegen = PhysicsCodegen::default();
        let module = codegen.gen_physics_module();
        assert!(module.contains("ideal_gas_pressure"));
        assert!(module.contains("kinetic_energy"));
        assert!(module.contains("drag_force"));
    }
    
    #[test]
    fn test_expression_compiler() {
        let mut compiler = ExpressionCompiler::default();
        compiler.add_variable("x", "position.x");
        
        let result = compiler.compile("x^2 + pi");
        assert!(result.contains("position.x"));
        assert!(result.contains(".powi(2)"));
    }
}
